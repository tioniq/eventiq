{"version":3,"sources":["../src/comparer.ts","../src/variable.ts","../src/linked-chain.ts","../src/vars/compound.ts","../src/vars/and.ts","../src/vars/combined.ts","../src/vars/constant.ts","../src/vars/delegate.ts","../src/vars/direct.ts","../src/vars/func.ts","../src/vars/invert.ts","../src/vars/map.ts","../src/vars/max.ts","../src/vars/min.ts","../src/vars/mutable.ts","../src/vars/or.ts","../src/vars/seal.ts","../src/vars/sum.ts","../src/vars/switch-map.ts","../src/vars/throttled.ts","../src/extensions.ts","../src/noop.ts","../src/functions.ts","../src/events/observer.ts","../src/events/dispatcher.ts","../src/events/stub.ts","../src/events/lazy.ts","../src/events/functions.ts","../src/events/extensions.ts","../src/is.ts"],"sourcesContent":["export type EqualityComparer<T> = (a: T, b: T) => boolean\n\nexport function strictEqualityComparer<T>(a: T, b: T) {\n  return a === b\n}\n\nexport function simpleEqualityComparer<T>(a: T, b: T) {\n  return a == b\n}\n\nexport const defaultEqualityComparer = strictEqualityComparer\n\nexport function functionEqualityComparer(a: Function, b: Function): boolean {\n  return a === b\n}\n","import {DisposableCompat} from \"@tioniq/disposiq\"\nimport {Func} from \"./action\"\nimport {EqualityComparer} from \"./comparer\"\n\n/**\n * Base Variable class. **All variables should extend this class**.\n * <p>\n * The general idea is that a **variable is a value that can be observed**. When the value changes, all subscribers are\n * notified. When we say 'changed', we mean that the value has changed according to the equality comparer. The default\n * equality comparer is the strict equality comparer.\n * </p>\n * <p>\n * You can subscribe to the variable using the `subscribe` or `subscribeSilent` methods.\n * The difference between them is that the **`subscribe` method will notify the subscriber immediately** after the\n * subscription, while the `subscribeSilent` method will not notify the subscriber immediately after the subscription.\n * </p>\n * @typeparam T - the type of the variable value\n */\nexport abstract class Variable<T> {\n  /**\n   * The current value of the variable\n   */\n  abstract get value(): T\n\n  /**\n   * The equality comparer used to compare the values of the variable\n   */\n  abstract get equalityComparer(): EqualityComparer<T>\n\n  /**\n   * Subscribes to the variable. The callback will be called immediately after the subscription and every time the value\n   * of the variable changes. You can unsubscribe by calling the `dispose` method of the returned object.\n   * @param callback the callback that will be called immediately after the subscription and every time the value of the\n   * variable changes\n   * @returns an object that can be used to unsubscribe\n   */\n  abstract subscribe(callback: Func<T, void>): DisposableCompat\n\n  /**\n   * Subscribes to the variable. The callback will not be called immediately after the subscription, only when the value\n   * of the variable changes. You can unsubscribe by calling the `dispose` method of the returned object.\n   * @param callback the callback that will be called every time the value of the variable changes\n   * @returns an object that can be used to unsubscribe\n   */\n  abstract subscribeSilent(callback: Func<T, void>): DisposableCompat\n\n  /**\n   * Checks if the value of the variable is equal to the specified value\n   * @param value the value to compare with\n   * @returns true if the value of the variable is equal to the specified value, false otherwise\n   */\n  equalTo(value: T): boolean {\n    return this.equalityComparer(this.value, value)\n  }\n\n  /**\n   * Overload of the `toString` method. Returns the string representation of the value of the variable\n   * @returns the string representation of the value of the variable\n   */\n  public toString(): string {\n    const _value = this.value\n    if (_value === null || _value === undefined) {\n      return `${_value}`\n    }\n    return _value.toString()\n  }\n\n  /**\n   * Overload of the `valueOf` method. Converts the variable to a primitive value, in this case, the value of the variable\n   * @returns the primitive value of the variable\n   */\n  public valueOf(): T {\n    return this.value\n  }\n}\n","import {DisposableAction, DisposableCompat} from \"@tioniq/disposiq\"\nimport {defaultEqualityComparer, EqualityComparer} from \"./comparer\"\n\ntype Action<T> = (value: T) => void\n\n/**\n * A linked chain is a collection of elements that can be iterated over. It is similar to a linked list, but it is\n * optimized for adding and removing elements. The implementation safely handles the addition and removal of elements during\n * iteration. The implementation is based on the Disposable pattern.\n */\nexport class LinkedChain<T> {\n  /**\n   * @internal\n   */\n  private readonly _equalityComparer: EqualityComparer<T>\n  /**\n   * @internal\n   */\n  private _head: ChainNode<T> | null = null\n  /**\n   * @internal\n   */\n  private _tail: ChainNode<T> | null = null\n  /**\n   * @internal\n   */\n  private _invoking: boolean = false\n  /**\n   * @internal\n   */\n  private _pendingHead: ChainNode<T> | null = null\n  /**\n   * @internal\n   */\n  private _pendingTail: ChainNode<T> | null = null\n  /**\n   * @internal\n   */\n  private _actionHead: ChainNode<Action<T>> | null = null\n\n  constructor(equalityComparer?: EqualityComparer<T>) {\n    this._equalityComparer = equalityComparer ?? defaultEqualityComparer\n  }\n\n  /**\n   * Checks if the chain has any elements\n   */\n  get hasAny(): boolean {\n    return this._head !== null || this._pendingHead !== null\n  }\n\n  /**\n   * Checks if the chain is empty\n   */\n  get empty(): boolean {\n    return this._head === null && this._pendingHead === null\n  }\n\n  /**\n   * Gets the number of elements in the chain\n   * @remarks This getter should be used only for debugging purposes\n   */\n  get count(): number {\n    let count = 0\n    let node = this._head\n    if (node !== null) {\n      do {\n        ++count\n        node = node.next\n      } while (node !== null)\n    }\n    node = this._pendingHead\n    if (node !== null) {\n      do {\n        count++\n        node = node.next\n      } while (node !== null)\n    }\n    return count\n  }\n\n  /**\n   * Converts the chain to an array\n   * @returns an array containing the elements of the chain\n   * @remarks This method should be used only for debugging purposes\n   */\n  toArray(): T[] {\n    const count = this.count\n    if (count === 0) {\n      return []\n    }\n    const array = new Array<T>(count)\n    let node = this._head\n    let index = 0\n    if (node !== null) {\n      do {\n        array[index++] = node.value\n        node = node.next\n      } while (node !== null)\n    }\n    node = this._pendingHead\n    if (node !== null) {\n      do {\n        array[index++] = node.value\n        node = node.next\n      } while (node !== null)\n    }\n    return array\n  }\n\n  /**\n   * Adds an element to the chain. If the element is already in the chain, it will not be added again.\n   * @param value the element to add\n   * @returns an array containing the subscription and a boolean value indicating if the element was added\n   */\n  addUnique(value: T): [subscription: DisposableCompat, added: boolean] {\n    const existing = this._findNode(value)\n    if (existing !== null) {\n      return [new DisposableAction(() => this._unlinkNode(existing)), false]\n    }\n    return [this.add(value), true]\n  }\n\n  /**\n   * Adds an element to the end of the chain\n   * @param value the element to add\n   * @returns a subscription that can be used to remove the element from the chain\n   */\n  add(value: T): DisposableCompat {\n    let node: ChainNode<T>\n    if (this._invoking) {\n      if (this._pendingHead === null) {\n        node = new ChainNode(value)\n        this._pendingHead = node\n        this._pendingTail = node\n      } else {\n        node = new ChainNode(value, this._pendingTail, null)\n        this._pendingTail!.next = node\n        this._pendingTail = node\n      }\n      return new DisposableAction(() => this._unlinkNode(node))\n    }\n    if (this._head === null) {\n      node = new ChainNode(value)\n      this._head = node\n      this._tail = node\n    } else {\n      node = new ChainNode(value, this._tail, null)\n      this._tail!.next = node\n      this._tail = node\n    }\n    return new DisposableAction(() => this._unlinkNode(node))\n  }\n\n  /**\n   * Adds an element to the beginning of the chain. If the element is already in the chain, it will not be added again.\n   * @param value the element to add\n   * @returns an array containing the subscription and a boolean value indicating if the element was added\n   */\n  addToBeginUnique(value: T): [subscription: DisposableCompat, added: boolean] {\n    const existing = this._findNode(value)\n    if (existing !== null) {\n      return [new DisposableAction(() => this._unlinkNode(existing)), false]\n    }\n    return [this.addToBegin(value), true]\n  }\n\n  /**\n   * Adds an element to the beginning of the chain\n   * @param value the element to add\n   * @returns a subscription that can be used to remove the element from the chain\n   */\n  addToBegin(value: T): DisposableCompat {\n    let node: ChainNode<T>\n    if (this._head === null) {\n      node = new ChainNode(value)\n      this._head = node\n      this._tail = node\n    } else {\n      node = new ChainNode(value, null, this._head)\n      this._head.previous = node\n      this._head = node\n    }\n    return new DisposableAction(() => this._unlinkNode(node))\n  }\n\n  /**\n   * Adds a node and its children to the end of the chain\n   * @param node\n   * @remarks This method does not check if the node is already in a chain\n   */\n  addToBeginNode(node: ChainNode<T>): void {\n    let chainNode = LinkedChain._clearNode(node)\n    if (chainNode === null) {\n      return\n    }\n    if (this._head === null) {\n      this._head = chainNode\n      while (chainNode.next !== null) {\n        chainNode = chainNode.next\n      }\n      this._tail = chainNode\n      return\n    }\n    let tail = chainNode\n    while (tail.next !== null) {\n      tail = tail.next\n    }\n    tail.next = this._head\n    this._head.previous = tail\n    this._head = chainNode\n  }\n\n  /**\n   * Removes an element from the chain\n   * @param value the element to remove\n   * @returns true if the element was removed, false otherwise\n   */\n  remove(value: T): boolean {\n    let checkNode = this._head\n    while (checkNode !== null) {\n      if (this._equalityComparer(checkNode.value, value)) {\n        this._unlinkNode(checkNode)\n        return true\n      }\n      checkNode = checkNode.next\n    }\n    checkNode = this._pendingHead\n    while (checkNode !== null) {\n      if (this._equalityComparer(checkNode.value, value)) {\n        this._unlinkNode(checkNode)\n        return true\n      }\n      checkNode = checkNode.next\n    }\n    return false\n  }\n\n  /**\n   * Removes all elements from the chain\n   */\n  clear(): void {\n    let node = this._head\n    if (node !== null) {\n      while (node !== null) {\n        node.disposed = true\n        node = node.next\n      }\n      this._head = null\n      this._tail = null\n    }\n    node = this._pendingHead\n    if (node !== null) {\n      while (node !== null) {\n        node.disposed = true\n        node = node.next\n      }\n      this._pendingHead = null\n      this._pendingTail = null\n    }\n  }\n\n  /**\n   * Removes all elements from the chain and returns the head node\n   * @returns the head node of the chain or null if the chain is empty\n   */\n  removeAll(): ChainNode<T> | null {\n    let node = this._head\n    this._head = null\n    this._tail = null\n    return node\n  }\n\n  /**\n   * Iterates over the elements of the chain and invokes the specified action for each element\n   * @param valueHandler the action to invoke for each element\n   */\n  forEach(valueHandler: Action<T>): void {\n    while (valueHandler !== null) {\n      if (this._head !== null) {\n        if (this._invoking) {\n          if (this._actionHead == null) {\n            this._actionHead = new ChainNode<Action<T>>(valueHandler)\n            return\n          }\n          let actionTail = this._actionHead\n          while (actionTail.next !== null) {\n            actionTail = actionTail.next\n          }\n          actionTail.next = new ChainNode<Action<T>>(valueHandler, actionTail, null)\n          return\n        }\n        this._invoking = true\n        let node: ChainNode<T> | null = this._head\n        while (node !== null) {\n          if (!node.disposed) {\n            valueHandler(node.value)\n          }\n          node = node.next\n        }\n        this._invoking = false\n\n        if (this._pendingHead != null) {\n          if (this._head == null) {\n            this._head = this._pendingHead\n            this._tail = this._pendingTail\n          } else {\n            this._pendingHead.previous = this._tail\n            this._tail!.next = this._pendingHead\n            this._tail = this._pendingTail\n          }\n          this._pendingHead = null\n          this._pendingTail = null\n        }\n      }\n      if (this._actionHead == null) {\n        return\n      }\n      let nextActionNode = this._actionHead\n      nextActionNode.disposed = true\n      this._actionHead = nextActionNode.next\n      if (this._actionHead != null) {\n        this._actionHead.previous = null\n        nextActionNode.next = null\n      }\n      valueHandler = nextActionNode.value\n    }\n  }\n\n  /**\n   * @internal\n   */\n  private _findNode(value: T): ChainNode<T> | null {\n    let checkNode = this._head\n    while (checkNode !== null) {\n      if (this._equalityComparer(checkNode.value, value)) {\n        return checkNode\n      }\n      checkNode = checkNode.next\n    }\n    if (this._invoking) {\n      checkNode = this._pendingHead\n      while (checkNode !== null) {\n        if (this._equalityComparer(checkNode.value, value)) {\n          return checkNode\n        }\n        checkNode = checkNode.next\n      }\n    }\n    return null\n  }\n\n  /**\n   * @internal\n   */\n  private _unlinkNode(node: ChainNode<T>): void {\n    if (node.disposed) {\n      return\n    }\n    node.disposed = true\n    if (node === this._head) {\n      if (node.next === null) {\n        this._head = null\n        this._tail = null\n        return\n      }\n      this._head = node.next\n      this._head.previous = null\n      return\n    }\n    if (node === this._tail) {\n      this._tail = node.previous\n      this._tail!.next = null\n      return\n    }\n    if (node === this._pendingHead) {\n      if (node.next == null) {\n        this._pendingHead = null\n        this._pendingTail = null\n        return\n      }\n      this._pendingHead = node.next\n      this._pendingHead.previous = null\n      return\n    }\n    if (node === this._pendingTail) {\n      this._pendingTail = node.previous\n      this._pendingTail!.next = null\n      return\n    }\n    if (node.previous !== null) {\n      node.previous.next = node.next\n    }\n    if (node.next !== null) {\n      node.next.previous = node.previous\n    }\n  }\n\n  /**\n   * @internal\n   */\n  private static _clearNode<T>(node: ChainNode<T> | null): ChainNode<T> | null {\n    let root: ChainNode<T> | null = null\n    let tail: ChainNode<T> | null = null\n    let next: ChainNode<T> | null = node\n    while (next !== null) {\n      node = next\n      next = node.next\n      if (node.disposed) {\n        continue\n      }\n      if (root === null) {\n        root = node\n        tail = node\n        node.previous = null\n        continue\n      }\n      tail!.next = node\n      node.previous = tail\n      tail = node\n    }\n    if (tail !== null) {\n      tail.next = null\n    }\n    return root\n  }\n}\n\nclass ChainNode<T> {\n  readonly value: T\n  next: ChainNode<T> | null\n  previous: ChainNode<T> | null\n  disposed: boolean = false\n\n  constructor(value: T, previous?: ChainNode<T> | null, next?: ChainNode<T> | null) {\n    this.value = value\n    this.previous = previous ?? null\n    this.next = next ?? null\n  }\n}","import {Variable} from \"../variable\"\nimport {defaultEqualityComparer, EqualityComparer, functionEqualityComparer} from \"../comparer\"\nimport {LinkedChain} from \"../linked-chain\"\nimport {Action, Func} from \"../action\"\nimport {DisposableAction, DisposableCompat} from \"@tioniq/disposiq\"\n\n/**\n * A Variable class that is base for common compound variables. It provides a functionality to react on subscription\n * activation and deactivation. Most variables are extending this class\n * @typeparam T - the type of the variable value\n */\nexport abstract class CompoundVariable<T> extends Variable<T> {\n  /**\n   * @internal\n   */\n  private readonly _chain = new LinkedChain<Action<T>>(functionEqualityComparer)\n\n  /**\n   * @internal\n   */\n  private readonly _equalityComparer: EqualityComparer<T>\n\n  /**\n   * @internal\n   */\n  private _value: T\n\n  protected constructor(initValue: T, equalityComparer?: EqualityComparer<T>) {\n    super()\n    this._value = initValue\n    this._equalityComparer = equalityComparer ?? defaultEqualityComparer\n  }\n\n  /**\n   * Checks if there are any subscriptions\n   * @returns true if there are any subscriptions, false otherwise\n   */\n  protected get active(): boolean {\n    return this._chain.hasAny\n  }\n\n  get value(): T {\n    if (this._chain.hasAny) {\n      return this._value\n    }\n    return this.getExactValue()\n  }\n\n  /**\n   * Sets the value of the variable. If the value is the same as the current value, the method will do nothing\n   * @param value the new value of the variable\n   * @protected internal use only\n   */\n  protected set value(value: T) {\n    if (this._equalityComparer(value, this._value)) {\n      return\n    }\n    this._value = value\n    this._chain.forEach(a => a(value))\n  }\n\n  get equalityComparer(): EqualityComparer<T> {\n    return this._equalityComparer\n  }\n\n  subscribe(callback: Func<T, void>): DisposableCompat {\n    if (this._chain.empty) {\n      this.activate()\n    }\n    const [disposable, added] = this._chain.addUnique(callback)\n    if (added) {\n      callback(this._value)\n    }\n    return new DisposableAction(() => {\n      disposable.dispose()\n      if (this._chain.empty) {\n        this.deactivate()\n      }\n    })\n  }\n\n  subscribeSilent(callback: Func<T, void>): DisposableCompat {\n    if (this._chain.empty) {\n      this.activate()\n    }\n    const disposable = this._chain.addUnique(callback)[0]\n    return new DisposableAction(() => {\n      disposable.dispose()\n      if (this._chain.empty) {\n        this.deactivate()\n      }\n    })\n  }\n\n  /**\n   * A method for activating functionality for the variable. It is called when at least one subscription is added\n   * @protected internal use only\n   */\n  protected abstract activate(): void\n\n  /**\n   * A method for deactivating functionality for the variable. It is called when the last subscription is removed\n   * @protected internal use only\n   */\n  protected abstract deactivate(): void\n\n  /**\n   * A method for getting the exact value of the variable. It is called when there are no subscriptions\n   * @protected internal use only\n   * @returns the default behavior is to return the current (last) value of the variable\n   * @remarks this method should be implemented in the derived class\n   */\n  protected getExactValue(): T {\n    return this._value\n  }\n\n  /**\n   * A method for setting the value of the variable without notifying subscribers\n   * @protected internal use only\n   * @param value the new value of the variable\n   */\n  protected setValueSilent(value: T): void {\n    this._value = value\n  }\n\n  /**\n   * A method for setting the value of the variable and notifying subscribers without checking the equality\n   * @protected internal use only\n   * @param value the new value of the variable\n   */\n  protected setValueForce(value: T): void {\n    this._value = value\n    this._chain.forEach(a => a(value))\n  }\n\n  /**\n   * A method for notifying subscribers about the value change\n   * @protected internal use only\n   */\n  protected notify(): void {\n    const value = this._value\n    this._chain.forEach(a => a(value))\n  }\n}","import {CompoundVariable} from \"./compound\";\nimport {Variable} from \"../variable\";\nimport {disposeAll, IDisposable} from \"@tioniq/disposiq\";\n\n/**\n * A variable that will return true if all the variable values are true\n */\nexport class AndVariable extends CompoundVariable<boolean> {\n  /**\n   * @internal\n   */\n  private readonly _variables: Variable<boolean>[];\n\n  /**\n   * @internal\n   */\n  private readonly _subscriptions: IDisposable[] = []\n\n  constructor(variables: Variable<boolean>[]) {\n    super(false);\n    this._variables = variables;\n  }\n\n  protected activate(): void {\n    this._listen(0)\n  }\n\n  protected deactivate(): void {\n    disposeAll(this._subscriptions);\n  }\n\n  protected getExactValue(): boolean {\n    const variables = this._variables\n    for (let i = 0; i < variables.length; ++i) {\n      if (!variables[i].value) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @internal\n   */\n  private _listen(index: number): void {\n    if (index >= this._variables.length) {\n      this.value = true;\n      return;\n    }\n    if (this._subscriptions.length > index) {\n      return\n    }\n    const __listener = (value: boolean) => {\n      if (value) {\n        this._listen(index + 1)\n      } else {\n        this._unsubscribeFrom(index + 1)\n        this.value = false\n      }\n    }\n    const variable = this._variables[index];\n    this._subscriptions.push(variable.subscribeSilent(__listener));\n    __listener(variable.value);\n    return;\n  }\n\n  /**\n   * @internal\n   */\n  private _unsubscribeFrom(index: number): void {\n    while (index < this._subscriptions.length) {\n      this._subscriptions.pop()?.dispose();\n    }\n  }\n}","import {CompoundVariable} from \"./compound\";\nimport {Variable} from \"../variable\";\nimport {EqualityComparer} from \"../comparer\";\nimport {DisposableStore} from \"@tioniq/disposiq\";\n\n/**\n * A variable that combines multiple variables into a single variable. The value presents an array of the values of the\n * variables. The variable will notify the subscribers on any of the variables change\n */\nexport class CombinedVariable<T extends any[]> extends CompoundVariable<T> {\n  /**\n   * @internal\n   */\n  private readonly _vars: Variable<T>[]\n\n  /**\n   * @internal\n   */\n  private readonly _subscriptions = new DisposableStore()\n\n  constructor(vars: { [K in keyof T]: Variable<T[K]> }) {\n    if (!vars?.length) {\n      throw new Error(\"No variables provided\")\n    }\n    const comparers = vars.map(v => v.equalityComparer)\n    super(getStubArray(vars.length), createArrayEqualityComparer(comparers))\n    this._vars = vars.slice()\n  }\n\n  protected activate(): void {\n    this._subscriptions.disposeCurrent()\n    const length = this._vars.length\n    const result = new Array(length) as T\n    for (let i = 0; i < length; ++i) {\n      const vary = this._vars[i]\n      this._subscriptions.add(vary.subscribeSilent(value => {\n        result[i] = value\n        this.setValueForce(result)\n      }))\n      result[i] = vary.value\n    }\n    this.setValueForce(result)\n  }\n\n  protected deactivate(): void {\n    this._subscriptions.disposeCurrent()\n  }\n\n  protected override getExactValue(): T {\n    const length = this._vars.length\n    const result = new Array(length) as T\n    for (let i = 0; i < length; ++i) {\n      result[i] = this._vars[i].value\n    }\n    return result\n  }\n}\n\nfunction createArrayEqualityComparer<K, T extends Array<K>>(itemEqualityComparers: EqualityComparer<K>[]): EqualityComparer<T> {\n  return function (a: T, b: T) {\n    if (a.length !== b.length) {\n      return false\n    }\n    for (let i = 0; i < a.length; ++i) {\n      if (!itemEqualityComparers[i](a[i], b[i])) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\nconst stubArray = Object.freeze([]) as unknown as any[]\n\nfunction getStubArray<T extends Array<unknown>>(length: number): T {\n  return stubArray as T\n}","import {Variable} from \"../variable\"\nimport {Func} from \"../action\"\nimport {DisposableCompat, emptyDisposable} from \"@tioniq/disposiq\"\nimport {defaultEqualityComparer, EqualityComparer} from \"../comparer\"\n\n/**\n * A variable that always has the same value\n * @typeparam T - the type of the variable value\n */\nexport class ConstantVariable<T> extends Variable<T> {\n  /**\n   * @internal\n   */\n  private readonly _value: T\n\n  /**\n   * @internal\n   */\n  private readonly _equalityComparer: EqualityComparer<T>\n\n  constructor(value: T, equalityComparer?: EqualityComparer<T>) {\n    super()\n    this._value = value\n    this._equalityComparer = equalityComparer ?? defaultEqualityComparer\n  }\n\n  get value(): T {\n    return this._value\n  }\n\n  get equalityComparer(): EqualityComparer<T> {\n    return this._equalityComparer\n  }\n\n  subscribe(callback: Func<T, void>): DisposableCompat {\n    callback(this._value)\n    return emptyDisposable\n  }\n\n  subscribeSilent(_: Func<T, void>): DisposableCompat {\n    return emptyDisposable\n  }\n}\n","import {CompoundVariable} from \"./compound\"\nimport {Variable} from \"../variable\"\nimport {DisposableAction, DisposableContainer, emptyDisposable, IDisposable} from \"@tioniq/disposiq\";\n\n/**\n * A variable that delegates its value to another variable\n * @typeparam T - the type of the variable value\n */\nexport class DelegateVariable<T> extends CompoundVariable<T> {\n  /**\n   * @internal\n   */\n  private readonly _sourceSubscription = new DisposableContainer()\n\n  /**\n   * @internal\n   */\n  private _source: Variable<T> | null\n\n  constructor(sourceOrDefaultValue?: Variable<T> | T | null) {\n    super(sourceOrDefaultValue instanceof Variable\n      ? null!\n      : sourceOrDefaultValue != undefined\n        ? sourceOrDefaultValue\n        : null!)\n    if (sourceOrDefaultValue instanceof Variable) {\n      this._source = sourceOrDefaultValue\n    } else {\n      this._source = null\n    }\n  }\n\n  /**\n   * Sets the source variable. The source variable will be used to get the value for the delegate variable\n   * @param source the source variable or null to remove the source\n   * @returns a disposable that will remove the source when disposed\n   */\n  setSource(source: Variable<T> | null): IDisposable {\n    if (!source) {\n      if (this._source) {\n        this.value = this._source.value\n        this._source = null\n      }\n      this._sourceSubscription.disposeCurrent()\n      return emptyDisposable\n    }\n    this._source = source\n    this._sourceSubscription.disposeCurrent()\n    if (this.active) {\n      this._sourceSubscription.set(source.subscribeSilent(v => this.setValueForce(v)))\n      this.value = source.value\n    }\n    return new DisposableAction(() => {\n      if (this._source !== source) {\n        return;\n      }\n      this.setSource(null)\n    });\n  }\n\n  protected activate() {\n    if (this._source === null) {\n      return\n    }\n    this._sourceSubscription.disposeCurrent()\n    this._sourceSubscription.set(this._source.subscribeSilent(v => this.setValueForce(v)))\n    this.value = this._source.value\n  }\n\n  protected deactivate() {\n    if (this._source === null) {\n      return\n    }\n    this._sourceSubscription.disposeCurrent()\n  }\n\n  protected getExactValue(): T {\n    return this._source !== null ? this._source.value : super.getExactValue()\n  }\n}","import {Variable} from \"../variable\"\nimport {DisposableCompat} from \"@tioniq/disposiq\"\nimport {Action, Func} from \"../action\"\nimport {defaultEqualityComparer, EqualityComparer, functionEqualityComparer} from \"../comparer\"\nimport {LinkedChain} from \"../linked-chain\";\n\n/**\n * A variable that can be changed by setting the value property. The 'direct' means that the change will not be checked\n * by the equality comparer\n */\nexport class DirectVariable<T> extends Variable<T> {\n  /**\n   * @internal\n   */\n  private readonly _chain = new LinkedChain<Action<T>>(functionEqualityComparer)\n\n  /**\n   * @internal\n   */\n  private readonly _equalityComparer: EqualityComparer<T>\n\n  /**\n   * @internal\n   */\n  private _value: T\n\n  constructor(initialValue: T, equalityComparer?: EqualityComparer<T>) {\n    super()\n    this._value = initialValue\n    this._equalityComparer = equalityComparer ?? defaultEqualityComparer\n  }\n\n  get value(): T {\n    return this._value\n  }\n\n  /**\n   * Sets the value of the variable and notifies all subscribers without checking the equality\n   * @param value the new value for the variable\n   */\n  set value(value: T) {\n    this._value = value\n    this._chain.forEach(a => a(value))\n  }\n\n  get equalityComparer(): EqualityComparer<T> {\n    return this._equalityComparer\n  }\n\n  subscribe(callback: Func<T, void>): DisposableCompat {\n    const [disposable, added] = this._chain.addUnique(callback)\n    if (added) {\n      callback(this._value)\n    }\n    return disposable\n  }\n\n  subscribeSilent(callback: Func<T, void>): DisposableCompat {\n    return this._chain.addUnique(callback)[0]\n  }\n\n  /**\n   * Sets the value of the variable without notifying the subscribers\n   * @param value the new value for the variable\n   * @remarks Use this method only if you are sure what you are doing. Combine this method with the `notify` method\n   */\n  setSilent(value: T): void {\n    this._value = value\n  }\n\n  /**\n   * Notifies all subscribers about the change of the value forcibly\n   * @remarks Use this method only if you are sure what you are doing. Combine this method with the `setSilent` method\n   */\n  notify(): void {\n    const value = this._value\n    this._chain.forEach(a => a(value))\n  }\n}","import {CompoundVariable} from \"./compound\"\nimport {Action, Func, Func0} from \"../action\"\nimport {DisposableContainer, IDisposable} from \"@tioniq/disposiq\"\n\n/**\n * A variable that reacts on subscription activation and deactivation using provided function called `activator`.\n * If there is no subscription, the variable will return the exact value provided by the `exactValue` function\n */\nexport class FuncVariable<T> extends CompoundVariable<T> {\n  /**\n   * @internal\n   */\n  private readonly _activator: Action<this>\n\n  /**\n   * @internal\n   */\n  private readonly _deactivator: Action<this>\n\n  /**\n   * @internal\n   */\n  private readonly _exactValue: Func0<T>\n\n  constructor(activate: Func<FuncVariable<T>, IDisposable>, exactValue: Func0<T>) {\n    super(null!)\n    const disposable = new DisposableContainer()\n    this._activator = (self) => {\n      disposable.disposeCurrent()\n      disposable.set(activate(self))\n    }\n    this._deactivator = () => {\n      disposable.disposeCurrent()\n    }\n    this._exactValue = exactValue\n  }\n\n  get value(): T {\n    return super.value\n  }\n\n  /**\n   * Sets the value of the variable. If the value is the same as the current value, the method will do nothing\n   * @param value the new value of the variable\n   */\n  set value(value: T) {\n    super.value = value\n  }\n\n  /**\n   * A method for setting the value of the variable and notifying subscribers without checking the equality\n   * @param value the new value of the variable\n   */\n  setValueForce(value: T) {\n    super.setValueForce(value)\n  }\n\n  /**\n   * A method for setting the value of the variable without notifying subscribers\n   * @param value the new value of the variable\n   */\n  setValueSilent(value: T) {\n    super.setValueSilent(value)\n  }\n\n  /**\n   * A method for notifying subscribers about the value change\n   */\n  notify() {\n    super.notify()\n  }\n\n  protected override activate(): void {\n    this._activator(this)\n  }\n\n  protected override deactivate(): void {\n    this._deactivator(this)\n  }\n\n  protected override getExactValue(): T {\n    return this._exactValue()\n  }\n}","import {DisposableAction, DisposableCompat, DisposableContainer} from \"@tioniq/disposiq\";\nimport {Action, Func} from \"../action\";\nimport {EqualityComparer, functionEqualityComparer} from \"../comparer\";\nimport {Variable} from \"../variable\";\nimport {LinkedChain} from \"../linked-chain\";\n\n/**\n * A variable that inverts the value of another variable\n */\nexport class InvertVariable extends Variable<boolean> {\n  /**\n   * @internal\n   */\n  private readonly _variable: Variable<boolean>\n\n  /**\n   * @internal\n   */\n  private readonly _chain = new LinkedChain<Action<boolean>>(functionEqualityComparer)\n\n  /**\n   * @internal\n   */\n  private _value: boolean = false\n\n  /**\n   * @internal\n   */\n  private readonly _subscription = new DisposableContainer()\n\n  constructor(variable: Variable<boolean>) {\n    super()\n    this._variable = variable\n  }\n\n  get value(): boolean {\n    if (this._chain.hasAny) {\n      return this._value\n    }\n    return !this._variable.value\n  }\n\n  get equalityComparer(): EqualityComparer<boolean> {\n    return this._variable.equalityComparer\n  }\n\n  subscribe(callback: Func<boolean, void>): DisposableCompat {\n    if (this._chain.empty) {\n      this._activate()\n    }\n    const [disposable, added] = this._chain.addUnique(callback)\n    if (added) {\n      callback(this._value)\n    }\n    return new DisposableAction(() => {\n      disposable.dispose()\n      if (this._chain.empty) {\n        this._deactivate()\n      }\n    })\n  }\n\n  subscribeSilent(callback: Func<boolean, void>): DisposableCompat {\n    return this._variable.subscribeSilent(value => callback(!value))\n  }\n\n  /**\n   * @internal\n   */\n  private _activate() {\n    this._subscription.disposeCurrent()\n    this._subscription.set(this._variable.subscribeSilent(v => {\n      const value = this._value = !v\n      this._chain.forEach(a => a(value))\n    }))\n    this._value = !this._variable.value\n  }\n\n  /**\n   * @internal\n   */\n  private _deactivate() {\n    this._subscription.disposeCurrent()\n  }\n}","import {CompoundVariable} from \"./compound\"\nimport {Variable} from \"../variable\"\nimport {Func} from \"../action\"\nimport {DisposableContainer} from \"@tioniq/disposiq\"\nimport {EqualityComparer} from \"../comparer\"\n\n/**\n * A variable that maps the value of another variable to a new value\n * @typeparam TInput - the type of the input variable value\n * @typeparam TOutput - the type of the output variable value\n */\nexport class MapVariable<TInput, TOutput> extends CompoundVariable<TOutput> {\n  /**\n   * @internal\n   */\n  private readonly _variable: Variable<TInput>\n\n  /**\n   * @internal\n   */\n  private readonly _mapper: Func<TInput, TOutput>\n\n  /**\n   * @internal\n   */\n  private readonly _subscription = new DisposableContainer()\n\n  constructor(variable: Variable<TInput>, mapper: Func<TInput, TOutput>, equalityComparer?: EqualityComparer<TOutput>) {\n    super(mapper(variable.value), equalityComparer)\n    this._variable = variable\n    this._mapper = mapper\n  }\n\n  /**\n   * @internal\n   */\n  private readonly _listener = (value: TInput) => {\n    this.value = this._mapper(value)\n  }\n\n  protected override activate(): void {\n    this._subscription.disposeCurrent()\n    this._subscription.set(this._variable.subscribeSilent(this._listener))\n    this._listener(this._variable.value)\n  }\n\n  protected override deactivate(): void {\n    this._subscription.disposeCurrent()\n  }\n\n  protected override getExactValue(): TOutput {\n    return this._mapper(this._variable.value)\n  }\n}","import {CompoundVariable} from \"./compound\"\nimport {Variable} from \"../variable\"\nimport {DisposableStore} from \"@tioniq/disposiq\"\n\n/**\n * A variable that represents the maximum value of multiple provided variables\n */\nexport class MaxVariable extends CompoundVariable<number> {\n  /**\n   * @internal\n   */\n  private readonly _vars: Variable<number>[]\n\n  /**\n   * @internal\n   */\n  private readonly _subscriptions = new DisposableStore()\n\n  constructor(vars: Variable<number>[]) {\n    super(0)\n    this._vars = vars.slice()\n  }\n\n  protected activate() {\n    const vars = this._vars\n    const length = vars.length\n    const subscriptions = this._subscriptions\n    subscriptions.disposeCurrent()\n    for (let i = 0; i < length; ++i) {\n      subscriptions.add(vars[i].subscribeSilent(() => {\n        this.postValue()\n      }))\n    }\n    this.postValue()\n  }\n\n  protected deactivate() {\n    this._subscriptions.dispose()\n  }\n\n  protected getExactValue() {\n    const vars = this._vars\n    const length = vars.length\n    let result = Number.NEGATIVE_INFINITY\n    for (let i = 0; i < length; ++i) {\n      result = Math.max(result, vars[i].value)\n    }\n    return result\n  }\n\n  protected postValue() {\n    const vars = this._vars\n    const length = vars.length\n    let result = Number.NEGATIVE_INFINITY\n    for (let i = 0; i < length; ++i) {\n      result = Math.max(result, vars[i].value)\n    }\n    this.value = result\n  }\n}","import {CompoundVariable} from \"./compound\"\nimport {Variable} from \"../variable\"\nimport {DisposableStore} from \"@tioniq/disposiq\"\n\n/**\n * A variable that represents the minimum value of multiple provided variables\n */\nexport class MinVariable extends CompoundVariable<number> {\n  /**\n   * @internal\n   */\n  private readonly _vars: Variable<number>[]\n\n  /**\n   * @internal\n   */\n  private readonly _subscriptions = new DisposableStore()\n\n  constructor(vars: Variable<number>[]) {\n    super(0)\n    this._vars = vars.slice()\n  }\n\n  protected activate() {\n    const vars = this._vars\n    const length = vars.length\n    const subscriptions = this._subscriptions\n    subscriptions.disposeCurrent()\n    for (let i = 0; i < length; ++i) {\n      subscriptions.add(vars[i].subscribeSilent(() => {\n        this.postValue()\n      }))\n    }\n    this.postValue()\n  }\n\n  protected deactivate() {\n    this._subscriptions.dispose()\n  }\n\n  protected getExactValue() {\n    const vars = this._vars\n    const length = vars.length\n    let result = Number.POSITIVE_INFINITY\n    for (let i = 0; i < length; ++i) {\n      result = Math.min(result, vars[i].value)\n    }\n    return result\n  }\n\n  protected postValue() {\n    const vars = this._vars\n    const length = vars.length\n    let result = Number.POSITIVE_INFINITY\n    for (let i = 0; i < length; ++i) {\n      result = Math.min(result, vars[i].value)\n    }\n    this.value = result\n  }\n}","import {Variable} from \"../variable\"\nimport {defaultEqualityComparer, EqualityComparer, functionEqualityComparer} from \"../comparer\"\nimport {DisposableCompat} from \"@tioniq/disposiq\"\nimport {Action, Func} from \"../action\"\nimport {LinkedChain} from \"../linked-chain\"\n\n/**\n * A class that implements the Variable class and provides the ability to change the value of the variable.\n * The value will be changed only if the new value is different from the old value (checked by the equality comparer)\n * @typeparam T - the type of the variable value\n */\nexport class MutableVariable<T> extends Variable<T> {\n  /**\n   * @internal\n   */\n  private readonly _chain = new LinkedChain<Action<T>>(functionEqualityComparer)\n\n  /**\n   * @internal\n   */\n  private readonly _equalityComparer: EqualityComparer<T>\n\n  /**\n   * @internal\n   */\n  private _value: T\n\n  constructor(value: T, equalityComparer?: EqualityComparer<T>) {\n    super()\n    this._value = value\n    this._equalityComparer = equalityComparer ?? defaultEqualityComparer\n  }\n\n  get value(): T {\n    return this._value\n  }\n\n  /**\n   * Sets the value of the variable. The value will be changed only if the new value is different from the old value\n   * @param value the new value for the variable\n   */\n  set value(value: T) {\n    if (this._equalityComparer(value, this._value)) {\n      return\n    }\n    this._value = value\n    this._chain.forEach(a => a(value))\n  }\n\n  get equalityComparer(): EqualityComparer<T> {\n    return this._equalityComparer\n  }\n\n  subscribe(callback: Func<T, void>): DisposableCompat {\n    const [disposable, added] = this._chain.addUnique(callback)\n    if (added) {\n      callback(this._value)\n    }\n    return disposable\n  }\n\n  subscribeSilent(callback: Func<T, void>): DisposableCompat {\n    return this._chain.addUnique(callback)[0]\n  }\n\n  /**\n   * Sets the value of the variable without notifying the subscribers\n   * @param value the new value for the variable\n   * @remarks Use this method only if you are sure what you are doing. Combine this method with the `notify` method\n   */\n  setSilent(value: T): void {\n    this._value = value\n  }\n\n  /**\n   * Notifies all subscribers about the change of the value forcibly\n   * @remarks Use this method only if you are sure what you are doing. Combine this method with the `setSilent` method\n   */\n  notify(): void {\n    const value = this._value\n    this._chain.forEach(a => a(value))\n  }\n}\n","import {CompoundVariable} from \"./compound\";\nimport {disposeAll, IDisposable} from \"@tioniq/disposiq\";\nimport {Variable} from \"../variable\";\n\n/**\n * A variable that will return true if any of the variable values are true\n */\nexport class OrVariable extends CompoundVariable<boolean> {\n  /**\n   * @internal\n   */\n  private readonly _variables: Variable<boolean>[];\n\n  /**\n   * @internal\n   */\n  private readonly _subscriptions: IDisposable[] = []\n\n  constructor(variables: Variable<boolean>[]) {\n    super(false);\n    this._variables = variables;\n  }\n\n  protected activate(): void {\n    this._listen(0)\n  }\n\n  protected deactivate(): void {\n    disposeAll(this._subscriptions);\n  }\n\n  protected getExactValue(): boolean {\n    const variables = this._variables\n    for (let i = 0; i < variables.length; ++i) {\n      if (variables[i].value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @internal\n   */\n  private _listen(index: number): void {\n    if (index >= this._variables.length) {\n      this.value = false;\n      return;\n    }\n    if (this._subscriptions.length > index) {\n      return\n    }\n    const __listener = (value: boolean) => {\n      if (value) {\n        this._unsubscribeFrom(index + 1)\n        this.value = true\n      } else {\n        this._listen(index + 1)\n      }\n    }\n    const variable = this._variables[index];\n    this._subscriptions.push(variable.subscribeSilent(__listener));\n    __listener(variable.value);\n    return;\n  }\n\n  /**\n   * @internal\n   */\n  private _unsubscribeFrom(index: number): void {\n    while (index < this._subscriptions.length) {\n      this._subscriptions.pop()?.dispose();\n    }\n  }\n}\n","import {Variable} from \"../variable\"\nimport {DisposableAction, DisposableCompat, DisposableContainer, emptyDisposable, IDisposable} from \"@tioniq/disposiq\";\nimport {Action, Func} from \"../action\";\nimport {LinkedChain} from \"../linked-chain\";\nimport {EqualityComparer, functionEqualityComparer} from \"../comparer\";\n\n/**\n * A variable that seals the value of another variable. When sealed, the variable will not change its value\n * @typeparam T - the type of the variable value\n */\nexport class SealVariable<T> extends Variable<T> {\n  /**\n   * @internal\n   */\n  private readonly _chain = new LinkedChain<Action<T>>(functionEqualityComparer)\n\n  /**\n   * @internal\n   */\n  private readonly _varSubscription = new DisposableContainer()\n\n  /**\n   * @internal\n   */\n  private readonly _equalityComparer: EqualityComparer<T>\n\n  /**\n   * @internal\n   */\n  private readonly _var: Variable<T>\n\n  /**\n   * @internal\n   */\n  private _value: T = null!\n\n  /**\n   * @internal\n   */\n  private _sealed = false\n\n  constructor(vary: Variable<T>, equalityComparer?: EqualityComparer<T>) {\n    super()\n    this._var = vary\n    this._equalityComparer = typeof equalityComparer === \"function\" ? equalityComparer : vary.equalityComparer\n  }\n\n  get value(): T {\n    if (this._sealed) {\n      return this._value\n    }\n    if (this._chain.empty) {\n      return this._var.value\n    }\n    return this._value\n  }\n\n  get equalityComparer(): EqualityComparer<T> {\n    return this._equalityComparer\n  }\n\n  subscribe(callback: Func<T, void>): DisposableCompat {\n    if (this._sealed) {\n      callback(this._value)\n      return emptyDisposable\n    }\n    if (this._chain.empty) {\n      this._activate()\n    }\n    const [disposable, added] = this._chain.addUnique(callback)\n    if (added) {\n      callback(this._value)\n    }\n    return new DisposableAction(() => {\n      disposable.dispose()\n      if (!this._sealed && this._chain.empty) {\n        this._deactivate()\n      }\n    })\n  }\n\n  subscribeSilent(callback: Func<T, void>): DisposableCompat {\n    if (this._sealed) {\n      return emptyDisposable\n    }\n    if (this._chain.empty) {\n      this._activate()\n    }\n    const disposable = this._chain.addUnique(callback)[0]\n    return new DisposableAction(() => {\n      disposable.dispose()\n      if (!this._sealed && this._chain.empty) {\n        this._deactivate()\n      }\n    })\n  }\n\n  /**\n   * Seals the variable. If the variable is already sealed, the method will do nothing\n   * @param valueToSeal the value to seal. If the value is not provided, the current value of the variable will be\n   * sealed\n   * @returns true if the variable was sealed, false if the variable was already sealed\n   */\n  seal(valueToSeal?: T): boolean {\n    if (this._sealed) {\n      return false\n    }\n    this._sealed = true\n    this._varSubscription.dispose()\n    if (arguments.length === 0) {\n      let currentValue = this._chain.empty ? this._var.value : this._value\n      this._varSubscription.dispose()\n      this._sealValue(currentValue)\n      return true\n    }\n    this._varSubscription.dispose()\n    this._sealValue(valueToSeal!)\n    return true\n  }\n\n  /**\n   * @internal\n   */\n  private _activate() {\n    this._varSubscription.disposeCurrent()\n    this._varSubscription.set(this._var.subscribeSilent(v => {\n      this._value = v\n      this._chain.forEach(a => a(v))\n    }))\n    this._value = this._var.value\n  }\n\n  /**\n   * @internal\n   */\n  private _deactivate() {\n    this._varSubscription.disposeCurrent()\n  }\n\n  /**\n   * @internal\n   */\n  private _sealValue(value: T): void {\n    if (this._equalityComparer(value, this._value)) {\n      this._chain.clear()\n      return\n    }\n    this._value = value\n    this._chain.forEach(a => a(value))\n    this._chain.clear()\n  }\n}","import {CompoundVariable} from \"./compound\"\nimport {Variable} from \"../variable\"\nimport {DisposableStore} from \"@tioniq/disposiq\";\n\n/**\n * A variable that represents the sum of multiple provided variables. If the type of the variables is boolean, the\n * sum will be the number of true values. If the type of the variables is number, the sum will be the sum of the values\n * @typeparam T - the type of the variables\n */\nexport class SumVariable<T extends number | boolean> extends CompoundVariable<number> {\n  /**\n   * @internal\n   */\n  private readonly _vars: Variable<T>[]\n\n  /**\n   * @internal\n   */\n  private readonly _subscriptions = new DisposableStore()\n\n  constructor(vars: Variable<T>[]) {\n    super(0)\n    this._vars = vars.slice()\n  }\n\n  protected activate(): void {\n    const vars = this._vars\n    const length = vars.length\n    const subscriptions = this._subscriptions\n    subscriptions.disposeCurrent()\n    for (let i = 0; i < length; ++i) {\n      const variable = vars[i]\n      subscriptions.add(variable.subscribeSilent(() => {\n        this.postValue()\n      }))\n    }\n    this.postValue()\n  }\n\n  protected deactivate(): void {\n    this._subscriptions.dispose()\n  }\n\n  protected getExactValue(): number {\n    const vars = this._vars\n    const length = vars.length\n    let result = 0\n    for (let i = 0; i < length; ++i) {\n      result += vars[i].value as number\n    }\n    return result\n  }\n\n  protected postValue(): void {\n    const vars = this._vars\n    const length = vars.length\n    let result = 0\n    for (let i = 0; i < length; ++i) {\n      result += vars[i].value as number\n    }\n    this.value = result\n  }\n}","import {CompoundVariable} from \"./compound\"\nimport {Variable} from \"../variable\"\nimport {DisposableContainer} from \"@tioniq/disposiq\"\n\nexport type SwitchMapMapper<TInput, TResult> = (input: TInput) => Variable<TResult>\n\n/**\n * A variable that switches the value of another variable to a new value based on mapper that returns another variable\n * @typeparam TInput - the type of the input variable value\n * @typeparam TResult - the type of the output variable value\n */\nexport class SwitchMapVariable<TInput, TResult> extends CompoundVariable<TResult> {\n  /**\n   * @internal\n   */\n  private readonly _switchSubscription = new DisposableContainer()\n\n  /**\n   * @internal\n   */\n  private readonly _varSubscription = new DisposableContainer()\n\n  /**\n   * @internal\n   */\n  private readonly _var: Variable<TInput>\n\n  /**\n   * @internal\n   */\n  private readonly _mapper: SwitchMapMapper<TInput, TResult>\n\n  constructor(vary: Variable<TInput>, mapper: SwitchMapMapper<TInput, TResult>) {\n    super(null!)\n    this._var = vary\n    this._mapper = mapper\n  }\n\n  protected activate(): void {\n    this._switchSubscription.disposeCurrent()\n    this._switchSubscription.set(this._var.subscribeSilent(i => this._handleSwitch(i)))\n    this._handleSwitch(this._var.value)\n  }\n\n  protected deactivate(): void {\n    this._switchSubscription.disposeCurrent()\n    this._varSubscription.disposeCurrent()\n  }\n\n  protected getExactValue(): TResult {\n    return this._mapper(this._var.value).value\n  }\n\n  /**\n   * @internal\n   */\n  private _handleSwitch(input: TInput): void {\n    this._varSubscription.disposeCurrent()\n    const mappedVariable = this._mapper(input)\n    this._varSubscription.set(mappedVariable.subscribeSilent(result => this.value = result))\n    this.value = mappedVariable.value\n  }\n}","import {CompoundVariable} from \"./compound\"\nimport {Variable} from \"../variable\";\nimport {DisposableContainer} from \"@tioniq/disposiq\";\nimport {EventObserver} from \"../events\";\n\nconst noScheduledValue = Object.freeze({})\n\n/**\n * A variable that will throttle the updates of the given variable. The throttler is an event observer that will\n * be subscribed where the updates will be scheduled. When the event is dispatched, the throttler will update the\n * value of the variable\n * @typeparam T - the type of the variable value\n */\nexport class ThrottledVariable<T> extends CompoundVariable<T> {\n  /**\n   * @internal\n   */\n  private readonly _subscription = new DisposableContainer()\n\n  /**\n   * @internal\n   */\n  private readonly _updateSubscription = new DisposableContainer()\n\n  /**\n   * @internal\n   */\n  private readonly _var: Variable<T>\n\n  /**\n   * @internal\n   */\n  private readonly _onUpdate: EventObserver\n\n  /**\n   * @internal\n   */\n  private _scheduledValue: T | typeof noScheduledValue = noScheduledValue\n\n  constructor(vary: Variable<T>, onUpdate: EventObserver) {\n    super(null!, vary.equalityComparer)\n    this._var = vary\n    this._onUpdate = onUpdate\n  }\n\n  protected activate(): void {\n    this._subscription.disposeCurrent()\n    this._subscription.set(this._var.subscribeSilent(v => {\n      this._scheduleUpdate(v)\n    }))\n    this.value = this._var.value\n  }\n\n  protected deactivate(): void {\n    this._subscription.disposeCurrent()\n    this._updateSubscription.disposeCurrent()\n  }\n\n  protected getExactValue(): T {\n    return this._var.value\n  }\n\n  /**\n   * @internal\n   */\n  private _scheduleUpdate(value: T) {\n    if (this._scheduledValue !== noScheduledValue) {\n      this._scheduledValue = value\n      return\n    }\n    this._scheduledValue = value\n    this._updateSubscription.disposeCurrent();\n    this._updateSubscription.set(this._onUpdate.subscribeOnce(() => {\n      const val = this._scheduledValue\n      this._scheduledValue = noScheduledValue\n      this.value = val === noScheduledValue ? this._var.value : val as T\n    }))\n  }\n}","import {Action, Func} from \"./action\"\nimport {Variable} from \"./variable\"\nimport {\n  ConstantVariable,\n  MapVariable,\n  MutableVariable,\n  SealVariable,\n  SumVariable,\n  SwitchMapMapper,\n  SwitchMapVariable\n} from \"./vars\"\nimport {OrVariable} from \"./vars\"\nimport {AndVariable} from \"./vars\"\nimport {InvertVariable} from \"./vars\"\nimport {\n  DisposableAction,\n  DisposableCompat,\n  DisposableContainer,\n  emptyDisposable,\n  IDisposable,\n  toDisposable\n} from \"@tioniq/disposiq\"\nimport {CombinedVariable} from \"./vars\"\nimport {ThrottledVariable} from \"./vars\";\nimport {EventObserver} from \"./events\";\nimport {noop} from \"./noop\";\nimport {createDelayDispatcher} from \"./functions\";\n\ndeclare module './variable' {\n  interface Variable<T> {\n    /**\n     * Subscribes to the variable. The callback can return a disposable object that will be disposed when a value is\n     * changed or the subscription is disposed\n     * @param callback the callback\n     * @returns an object that can be used to unsubscribe\n     */\n    subscribeDisposable<T>(callback: Func<T, IDisposable>): DisposableCompat\n\n    /**\n     * Subscribes to the variable and calls the callback once if the condition is met\n     * @param callback the callback\n     * @param condition the condition\n     * @returns an object that can be used to unsubscribe\n     */\n    subscribeOnceWhere(callback: Action<T>, condition: Func<T, boolean>): DisposableCompat\n\n    /**\n     * Maps the variable value to another value\n     * @param mapper the mapper\n     * @returns a new variable with the mapped value\n     */\n    map<TOutput>(mapper: Func<T, TOutput>): Variable<TOutput>\n\n    /**\n     * Creates a new variable that will return true if any of the variable values are true\n     * @param other the other variable\n     * @returns a new OR variable\n     */\n    or(this: Variable<boolean>, other: Variable<boolean>): Variable<boolean>\n\n    /**\n     * Creates a new variable that will return true if all the variable values are true\n     * @param other the other variable\n     * @returns a new AND variable\n     */\n    and(this: Variable<boolean>, other: Variable<boolean>): Variable<boolean>\n\n    /**\n     * Inverts the variable value. If the value is true, the new value will be false and vice versa\n     * @returns a new variable with the inverted value\n     */\n    invert(this: Variable<boolean>): Variable<boolean>\n\n    /**\n     * Combines the variable with other variables\n     * @param others the other variables\n     * @returns a new variable with the combined values\n     */\n    with<O extends any[]>(...others: { [K in keyof O]: Variable<O[K]> }): Variable<[T, ...O]>\n\n    /**\n     * Maps the variable value to another value using the mapper that returns a new variable to subscribe\n     * @param mapper the mapper that returns another variable to subscribe\n     * @returns a new variable with the mapped value\n     */\n    switchMap<TResult>(mapper: SwitchMapMapper<T, TResult>): Variable<TResult>\n\n    /**\n     * Throttles the variable value changes\n     * @param delay the delay in milliseconds\n     * @returns a new variable with the throttled value\n     */\n    throttle<T>(delay: number): Variable<T>\n\n    /**\n     * Throttles the variable value changes\n     * @param onUpdate the event observer that will be used to throttle the value changes\n     * @returns a new variable with the throttled value\n     */\n    throttle<T>(onUpdate: EventObserver): Variable<T>\n\n    /**\n     * Streams the variable value to another mutable variable\n     * @param receiver the receiver variable\n     * @returns an object that can be used to unsubscribe\n     */\n    streamTo(receiver: MutableVariable<T>): DisposableCompat\n\n    /**\n     * Keeps the variable's subscription alive\n     * @returns an object that can be used to stop the persistence\n     */\n    startPersistent(): DisposableCompat\n\n    /**\n     * Creates a new variable that will return the sum of the variable values\n     * @param other the other variable or a value\n     * @returns a new SUM variable\n     */\n    plus(this: Variable<number>, other: Variable<number> | number): Variable<number>\n\n    /**\n     * Creates a new variable that will return the difference of the variable values\n     * @param other the other variable or a value\n     * @returns a new SUM variable\n     */\n    minus(this: Variable<number>, other: Variable<number> | number): Variable<number>\n\n    /**\n     * Creates a new variable that will return the product of the variable values\n     * @param other the other variable or a value\n     * @returns a new MULTIPLY variable\n     */\n    multiply(this: Variable<number>, other: Variable<number> | number): Variable<number>\n\n    /**\n     * Creates a new variable that will return the quotient of the variable values\n     * @param other the other variable or a value\n     * @returns a new DIVIDE variable\n     */\n    divide(this: Variable<number>, other: Variable<number> | number): Variable<number>\n\n    /**\n     * Creates a new variable that will return the rounded value of the variable\n     * @returns a new variable with the rounded value\n     */\n    round(this: Variable<number>): Variable<number>\n\n    /**\n     * Creates a new variable that will return true if the variable value is greater than the other value\n     * @param other the other variable or a value\n     * @returns a new variable with the comparison result\n     */\n    moreThan(this: Variable<number>, other: Variable<number> | number): Variable<boolean>\n\n    /**\n     * Creates a new variable that will return true if the variable value is less than the other value\n     * @param other the other variable or a value\n     * @returns a new variable with the comparison result\n     */\n    lessThan(this: Variable<number>, other: Variable<number> | number): Variable<boolean>\n\n    /**\n     * Creates a new variable that will return true if the variable value is greater or equal to the other value\n     * @param other the other variable or a value\n     * @returns a new variable with the comparison result\n     */\n    moreOrEqual(this: Variable<number>, other: Variable<number> | number): Variable<boolean>\n\n    /**\n     * Creates a new variable that will return true if the variable value is less or equal to the other value\n     * @param other the other variable or a value\n     * @returns a new variable with the comparison result\n     */\n    lessOrEqual(this: Variable<number>, other: Variable<number> | number): Variable<boolean>\n\n    /**\n     * Creates a new variable that will return true if the variable value is equal to the other value\n     * @param other the other variable or a value\n     * @returns a new variable with the comparison result\n     */\n    equal(other: Variable<T> | T): Variable<boolean>\n\n    /**\n     * Creates a new constant variable with the current value\n     * @returns a new variable with the sealed value\n     */\n    sealed(): Variable<T>\n\n    /**\n     * Creates a new variable that will stream the variable value until the condition is met\n     * @param condition the condition\n     * @returns a new variable that will be sealed when the condition is met\n     */\n    sealWhen(condition: Func<T, boolean> | T): Variable<T>\n  }\n}\n\nVariable.prototype.subscribeDisposable = function <T>(this: Variable<T>, callback: Func<T, IDisposable>): DisposableCompat {\n  const container = new DisposableContainer()\n  const subscription = this.subscribe(v => {\n    container.disposeCurrent()\n    container.set(toDisposable(callback(v)))\n  })\n  return new DisposableAction(() => {\n    subscription.dispose()\n    container.dispose()\n  })\n}\n\nVariable.prototype.subscribeOnceWhere = function <T>(this: Variable<T>, callback: Action<T>, condition: Func<T, boolean>): DisposableCompat {\n  const container = new DisposableContainer()\n  container.set(this.subscribeSilent(v => {\n    if (!condition(v)) {\n      return\n    }\n    container.dispose()\n    callback(v)\n  }))\n  const value = this.value\n  if (!condition(value)) {\n    return container\n  }\n  container.dispose()\n  callback(value)\n  return emptyDisposable\n}\n\nVariable.prototype.map = function <T, TOutput>(this: Variable<T>, mapper: Func<T, TOutput>): Variable<TOutput> {\n  return new MapVariable<T, TOutput>(this, mapper)\n}\n\nVariable.prototype.or = function (this: Variable<boolean>, other: Variable<boolean>): Variable<boolean> {\n  return new OrVariable([this, other])\n}\n\nVariable.prototype.and = function (this: Variable<boolean>, other: Variable<boolean>): Variable<boolean> {\n  return new AndVariable([this, other])\n}\n\nVariable.prototype.invert = function (this: Variable<boolean>): Variable<boolean> {\n  return new InvertVariable(this)\n}\n\nVariable.prototype.with = function <T, O extends any[]>(this: Variable<T>, ...others: { [K in keyof O]: Variable<O[K]> }): Variable<[T, ...O]> {\n  return new CombinedVariable<[T, ...O]>([this, ...others])\n}\n\nVariable.prototype.switchMap = function <TInput, TResult>(this: Variable<TInput>, mapper: SwitchMapMapper<TInput, TResult>): Variable<TResult> {\n  return new SwitchMapVariable<TInput, TResult>(this, mapper)\n}\n\nVariable.prototype.throttle = function <T>(this: Variable<T>, delay: number | EventObserver): Variable<T> {\n  if (typeof delay === 'number') {\n    return new ThrottledVariable(this, createDelayDispatcher(delay))\n  } else {\n    return new ThrottledVariable(this, delay)\n  }\n}\n\nVariable.prototype.streamTo = function <T>(this: Variable<T>, receiver: MutableVariable<T>): DisposableCompat {\n  return this.subscribe(value => receiver.value = value)\n}\n\nVariable.prototype.startPersistent = function <T>(this: Variable<T>): DisposableCompat {\n  return this.subscribeSilent(noop)\n}\n\nVariable.prototype.plus = function (this: Variable<number>, other: Variable<number> | number): Variable<number> {\n  if (other instanceof Variable) {\n    return new SumVariable([this, other])\n  }\n  return new MapVariable<number, number>(this, v => v + other)\n}\n\nVariable.prototype.minus = function (this: Variable<number>, other: Variable<number> | number): Variable<number> {\n  if (other instanceof Variable) {\n    return new SumVariable([this, new MapVariable<number, number>(other, v => -v)])\n  }\n  return new MapVariable<number, number>(this, v => v - other)\n}\n\nVariable.prototype.multiply = function (this: Variable<number>, other: Variable<number> | number): Variable<number> {\n  if (other instanceof Variable) {\n    return this.with(other).map(([a, b]) => a * b)\n  }\n  return new MapVariable<number, number>(this, v => v * other)\n}\n\nVariable.prototype.divide = function (this: Variable<number>, other: Variable<number> | number): Variable<number> {\n  if (other instanceof Variable) {\n    return this.with(other).map(([a, b]) => a / b)\n  }\n  return new MapVariable<number, number>(this, v => v / other)\n}\n\nVariable.prototype.round = function (this: Variable<number>): Variable<number> {\n  return new MapVariable<number, number>(this, Math.round)\n}\n\nVariable.prototype.moreThan = function (this: Variable<number>, other: Variable<number> | number): Variable<boolean> {\n  if (other instanceof Variable) {\n    return this.with(other).map(([a, b]) => a > b)\n  }\n  return new MapVariable<number, boolean>(this, v => v > other)\n}\n\nVariable.prototype.lessThan = function (this: Variable<number>, other: Variable<number> | number): Variable<boolean> {\n  if (other instanceof Variable) {\n    return this.with(other).map(([a, b]) => a < b)\n  }\n  return new MapVariable<number, boolean>(this, v => v < other)\n}\n\nVariable.prototype.moreOrEqual = function (this: Variable<number>, other: Variable<number> | number): Variable<boolean> {\n  if (other instanceof Variable) {\n    return this.with(other).map(([a, b]) => a >= b)\n  }\n  return new MapVariable<number, boolean>(this, v => v >= other)\n}\n\nVariable.prototype.lessOrEqual = function (this: Variable<number>, other: Variable<number> | number): Variable<boolean> {\n  if (other instanceof Variable) {\n    return this.with(other).map(([a, b]) => a <= b)\n  }\n  return new MapVariable<number, boolean>(this, v => v <= other)\n}\n\nVariable.prototype.equal = function <T>(this: Variable<T>, other: Variable<T> | T): Variable<boolean> {\n  if (other instanceof Variable) {\n    return this.with(other).map(([a, b]) => this.equalityComparer(a, b))\n  }\n  return new MapVariable<T, boolean>(this, v => this.equalityComparer(v, other))\n}\n\nVariable.prototype.sealed = function <T>(this: Variable<T>): Variable<T> {\n  return new ConstantVariable(this.value)\n}\n\nVariable.prototype.sealWhen = function <T>(this: Variable<T>, condition: Func<T, boolean> | T): Variable<T> {\n  const vary = new SealVariable(this)\n  if (typeof condition === 'function') {\n    vary.subscribeOnceWhere(v => vary.seal(v), condition as Func<T, boolean>)\n    return vary\n  }\n  vary.subscribeOnceWhere(v => vary.seal(v), v => this.equalityComparer(v, condition))\n  return vary\n}\n","export const noop = Object.freeze(function () {\n})","import {\n  FuncVariable,\n  ConstantVariable,\n  OrVariable,\n  AndVariable,\n  MinVariable,\n  MaxVariable,\n  SumVariable, DelegateVariable, DirectVariable\n} from \"./vars\"\nimport {DisposableAction, IDisposable} from \"@tioniq/disposiq\"\nimport {Func, Func0} from \"./action\"\nimport {Variable} from \"./variable\"\nimport {EventObserver, LazyEventDispatcher} from \"./events\";\n\n/**\n * Creates a new variable based on FuncVariable parameters\n * @param activator a function that will be called to activate the variable when it is subscribed\n * @param exactValue a function that returns the exact value of the variable when there is no subscriptions\n * @returns a new variable\n */\nexport function createVar<T>(activator: Func<FuncVariable<T>, IDisposable>, exactValue: Func0<T>): Variable<T> {\n  return new FuncVariable(activator, exactValue)\n}\n\n/**\n * Creates a new constant variable that will always have the same value\n * @param value the value of the variable\n * @returns a new constant variable\n */\nexport function createConst<T>(value: T): Variable<T> {\n  return new ConstantVariable(value)\n}\n\n/**\n * Creates a new delegate variable that can be changed by setting a source variable\n * @param sourceOrDefaultValue the source variable or the default value of the variable\n * @returns a new delegate variable\n */\nexport function createDelegate<T>(sourceOrDefaultValue?: Variable<T> | T | null): DelegateVariable<T> {\n  return new DelegateVariable(sourceOrDefaultValue)\n}\n\n/**\n * Creates a new direct variable that can be changed by setting the value property. The 'direct' means that the change\n * will not be checked by the equality comparer\n * @param initialValue the initial value of the variable\n * @returns a new direct variable\n */\nexport function createDirect<T>(initialValue: T): DirectVariable<T> {\n  return new DirectVariable(initialValue)\n}\n\n/**\n * Creates a new variable that will return true if any of the variables are true\n * @param variables the variables to check\n * @returns a new OR variable\n */\nexport function or(...variables: Variable<boolean>[]): Variable<boolean> {\n  return new OrVariable(variables)\n}\n\n/**\n * Creates a new variable that will return true if all the variables are true\n * @param variables the variables to check\n * @returns a new AND variable\n */\nexport function and(...variables: Variable<boolean>[]): Variable<boolean> {\n  return new AndVariable(variables)\n}\n\n/**\n * Creates a new variable that will return the sum of the variables\n * @param variables the variables to sum\n * @returns a new SUM variable\n */\nexport function sum<T extends number | boolean>(...variables: Variable<T>[]): Variable<number> {\n  return new SumVariable(variables)\n}\n\n/**\n * Creates a new variable that will return the minimum value of the variables\n * @param variables the variables to compare\n * @returns a new MIN variable\n */\nexport function min(...variables: Variable<number>[]): Variable<number> {\n  return new MinVariable(variables)\n}\n\n/**\n * Creates a new variable that will return the maximum value of the variables\n * @param variables the variables to compare\n * @returns a new MAX variable\n */\nexport function max(...variables: Variable<number>[]): Variable<number> {\n  return new MaxVariable(variables)\n}\n\n/**\n * Creates a new event dispatcher that will dispatch an event after a specified delay\n * @param delay the delay in milliseconds\n * @returns a new event dispatcher\n */\nexport function createDelayDispatcher(delay: number): EventObserver {\n  return new LazyEventDispatcher((dispatcher) => {\n    const timeout = setTimeout(() => dispatcher.dispatch(), delay)\n    return new DisposableAction(() => clearTimeout(timeout))\n  })\n}\n","import {Action} from \"../action\";\nimport {DisposableCompat} from \"@tioniq/disposiq\";\n\n/**\n * A base class for event observers. **All event observers should extend this class**.\n * <p>\n *   The general idea is that an **event observer is an object that can be subscribed to**. When the event is\n *   dispatched, all subscribers are notified. You can subscribe to the event observer using the `subscribe` method.\n *   The callback will be called every time the event is dispatched. You can unsubscribe by calling the `dispose`\n *   method of the returned object\n * </p>\n */\nexport abstract class EventObserver<T = void> {\n  /**\n   * Subscribes to the event observer. The callback will be called every time the event is dispatched. You can\n   * unsubscribe by calling the `dispose` method of the returned object\n   * @param callback the callback for the subscription\n   * @returns an object that can be used to unsubscribe\n   */\n  abstract subscribe(callback: Action<T>): DisposableCompat\n}\n","import {LinkedChain} from \"../linked-chain\";\nimport {Action} from \"../action\";\nimport {functionEqualityComparer} from \"../comparer\";\nimport {DisposableCompat} from \"@tioniq/disposiq\";\nimport {EventObserver} from \"./observer\";\n\n/**\n * A class that implements the EventObserver class and provides the ability to dispatch events by calling the `dispatch`\n * method\n * @typeparam T - the type of the event value\n */\nexport class EventDispatcher<T = void> extends EventObserver<T> {\n  /**\n   * @internal\n   */\n  private readonly _nodes = new LinkedChain<Action<T>>(functionEqualityComparer);\n\n  override subscribe(action: Action<T>): DisposableCompat {\n    return this._nodes.add(action);\n  }\n\n  /**\n   * Dispatches the event to all subscribers\n   * @param value the value of the event\n   */\n  dispatch(value: T): void {\n    this._nodes.forEach(a => a(value));\n  }\n\n  /**\n   * Checks if there are any subscriptions\n   * @returns true if there are any subscriptions, false otherwise\n   */\n  get hasSubscriptions(): boolean {\n    return this._nodes.hasAny\n  }\n}","import {EventObserver} from \"./observer\"\nimport {DisposableCompat, emptyDisposable} from \"@tioniq/disposiq\";\n\n/**\n * A stub for the EventObserver class.\n * <p>\n *   The purpose of this class is to provide a stub for the EventObserver class that does nothing\n * </p>\n * @typeparam T - the type of the event value\n */\nexport class EventObserverStub<T> extends EventObserver<T> {\n  subscribe(): DisposableCompat {\n    return emptyDisposable\n  }\n}","import {EventObserver} from \"./observer\"\nimport {Action, Func} from \"../action\"\nimport {DisposableAction, DisposableCompat, DisposableContainer, IDisposable, toDisposable} from \"@tioniq/disposiq\"\nimport {functionEqualityComparer} from \"../comparer\"\nimport {LinkedChain} from \"../linked-chain\"\n\n/**\n * A class that implements the EventObserver class in a lazy way. The implementation receives an activator function.\n * The activator will be activated only when there is at least one subscription. When the last subscription is disposed,\n * the activator will be deactivated. The activator can be reactivated when a new subscription is added.\n * <p>\n *   This class is useful when you need to activate some resources only when there are subscribers.\n *   subscribers.\n * </p>\n * @typeparam T - the type of the event value\n */\nexport class LazyEventDispatcher<T = void> extends EventObserver<T> {\n  private readonly _nodes = new LinkedChain<Action<T>>(functionEqualityComparer)\n  private readonly _subscription = new DisposableContainer()\n  private readonly _activator: Func<this, IDisposable>\n\n  constructor(activator: Func<LazyEventDispatcher<T>, IDisposable>) {\n    super()\n    this._activator = activator\n  }\n\n  /**\n   * Checks if there are any subscriptions\n   * @returns true if there are any subscriptions, false otherwise\n   */\n  get hasSubscription(): boolean {\n    return this._nodes.hasAny\n  }\n\n  override subscribe(callback: Action<T>): DisposableCompat {\n    let subscription: IDisposable\n    if (this._nodes.empty) {\n      subscription = this._nodes.add(callback)\n      this._activate()\n    } else {\n      subscription = this._nodes.add(callback)\n    }\n    return new DisposableAction(() => {\n      subscription.dispose()\n      if (this._nodes.hasAny) {\n        return\n      }\n      this._deactivate()\n    })\n  }\n\n  /**\n   * Dispatches the event to all subscribers\n   * @param value the value of the event\n   */\n  dispatch(value: T): void {\n    this._nodes.forEach(a => a(value))\n  }\n\n  /**\n   * @internal\n   */\n  private _activate() {\n    this._subscription.disposeCurrent()\n    this._subscription.set(toDisposable(this._activator(this)))\n  }\n\n  /**\n   * @internal\n   */\n  private _deactivate() {\n    this._subscription.disposeCurrent()\n  }\n}","import {EventObserver} from \"./observer\";\nimport {LazyEventDispatcher} from \"./lazy\";\nimport {DisposableStore} from \"@tioniq/disposiq\";\n\n/**\n * Merges multiple event observers into a single event observer. The resulting event observer will dispatch events\n * from all the given event observers.\n * @param observers the event observers to merge\n * @returns the merged event observer\n * @typeparam T - the type of the event value\n */\nexport function merge<T>(...observers: EventObserver<T>[]): EventObserver<T> {\n  return new LazyEventDispatcher<T>(dispatcher => {\n    const disposableStore = new DisposableStore();\n    for (const t of observers) {\n      disposableStore.add(t.subscribe(v => dispatcher.dispatch(v)));\n    }\n    return disposableStore;\n  });\n}\n","import {DisposableCompat, DisposableContainer, emptyDisposable} from \"@tioniq/disposiq\"\nimport {Action, Func} from \"../action\"\nimport {EventObserver} from \"./observer\"\nimport {Variable} from \"../variable\";\nimport {LazyEventDispatcher} from \"./lazy\";\nimport {EventDispatcher} from \"./dispatcher\";\n\ndeclare module './observer' {\n  interface EventObserver<T> {\n    /**\n     * Subscribes to the event observer. The callback will be called only once\n     * @param callback the callback for the subscription\n     * @returns an object that can be used to unsubscribe\n     */\n    subscribeOnce(callback: Action<T>): DisposableCompat\n\n    /**\n     * Subscribes to the event observer. The callback will be called only once when the condition is met\n     * @param callback the callback for the subscription\n     * @param condition the condition that must be met to call the callback\n     * @returns an object that can be used to unsubscribe\n     */\n    subscribeOnceWhere(callback: Action<T>, condition: Func<T, boolean>): DisposableCompat\n\n    /**\n     * Subscribes to the event observer. The callback will be called every time the event is dispatched when the\n     * condition is met\n     * @param callback the callback for the subscription\n     * @param condition the condition that must be met to call the callback\n     * @returns an object that can be used to unsubscribe\n     */\n    subscribeWhere(callback: Action<T>, condition: Func<T, boolean>): DisposableCompat\n\n    /**\n     * Subscribes to the event observer. The callback will be called only when the condition variable is true\n     * @param callback the callback for the subscription\n     * @param condition the condition that must be met to call the callback\n     * @returns an object that can be used to unsubscribe\n     */\n    subscribeOn(callback: Action<T>, condition: Variable<boolean>): DisposableCompat\n\n    /**\n     * Maps the event observer to a new event observer with a different type\n     * @param mapper the function that maps the value of the event observer to a new value\n     * @returns the new event observer\n     * @typeparam TOutput - the type of the new event observer\n     */\n    map<TOutput>(mapper: Func<T, TOutput>): EventObserver<TOutput>\n\n    /**\n     * Maps the event observer to a new by filtering the values\n     * @param condition the condition that must be met to dispatch the event\n     * @returns the new event observer\n     */\n    where(condition: Func<T, boolean>): EventObserver<T>\n  }\n}\n\ndeclare module './dispatcher' {\n  interface EventDispatcher<T> {\n    /**\n     * Dispatches the event to all subscribers. If an error occurs while dispatching the event, it will be caught\n     * @param value the value of the event\n     */\n    dispatchSafe(value: T): void\n  }\n}\n\nEventObserver.prototype.subscribeOnce = function <T>(this: EventObserver<T>, callback: Action<T>): DisposableCompat {\n  const subscription = new DisposableContainer()\n  subscription.set(this.subscribe(value => {\n    subscription.dispose()\n    callback(value)\n  }))\n  return subscription\n}\n\nEventObserver.prototype.subscribeOnceWhere = function <T>(this: EventObserver<T>, callback: Action<T>, condition: Func<T, boolean>): DisposableCompat {\n  const subscription = new DisposableContainer()\n  subscription.set(this.subscribe(value => {\n    if (!condition(value)) {\n      return\n    }\n    subscription.dispose()\n    callback(value)\n  }))\n  return subscription\n}\n\nEventObserver.prototype.subscribeWhere = function <T>(this: EventObserver<T>, callback: Action<T>, condition: Func<T, boolean>): DisposableCompat {\n  return this.subscribe(value => {\n    if (condition(value)) {\n      callback(value)\n    }\n  })\n}\n\nEventObserver.prototype.subscribeOn = function <T>(this: EventObserver<T>, callback: Action<T>, condition: Variable<boolean>): DisposableCompat {\n  return condition.subscribeDisposable(value => value ? this.subscribe(callback) : emptyDisposable)\n}\n\nEventObserver.prototype.map = function <T, TOutput>(this: EventObserver<T>, mapper: Func<T, TOutput>): EventObserver<TOutput> {\n  return new LazyEventDispatcher(dispatcher => this.subscribe(value => dispatcher.dispatch(mapper(value))))\n}\n\nEventObserver.prototype.where = function <T>(this: EventObserver<T>, condition: Func<T, boolean>): EventObserver<T> {\n  return new LazyEventDispatcher(dispatcher => this.subscribe(value => {\n    if (condition(value)) {\n      dispatcher.dispatch(value)\n    }\n  }))\n}\n\nEventDispatcher.prototype.dispatchSafe = function <T>(this: EventDispatcher<T>, value: T): void {\n  try {\n    this.dispatch(value)\n  } catch (e) {\n  }\n}","import {Variable} from \"./variable\";\n\n/**\n * Check if the value is a variable\n * @param value The value to check\n * @returns true if the value is a variable, false otherwise\n */\nexport function isVariable(value: any): value is Variable<unknown> {\n  return value instanceof Variable\n}\n\n/**\n * Check if the value is a variable of the specified type\n * @param value The value to check\n * @param typeCheckerOrExampleValue The type checker or the example value of the variable\n * @returns true if the value is a variable of the specified type, false otherwise\n * @remarks If the `typeCheckerOrExampleValue` is not provided, the function will return true if the value is a variable\n * @remarks If the `typeCheckerOrExampleValue` is an example value, the function will only check if the value type\n * matches the type of the example value. This means that if both the value and the example value are objects, the\n * function will return true without checking their properties or inheritance.\n */\nexport function isVariableOf<T>(value: any, typeCheckerOrExampleValue?: ((t: any) => t is T) | T): value is Variable<T> {\n  if (!(value instanceof Variable)) {\n    return false\n  }\n  let checker: (t: Variable<any>) => boolean\n  if (typeof typeCheckerOrExampleValue === \"function\") {\n    checker = typeCheckerOrExampleValue as (t: any) => boolean\n  } else if (typeof typeCheckerOrExampleValue === \"undefined\") {\n    checker = () => true\n  } else {\n    checker = (v: any) => typeof v === typeof typeCheckerOrExampleValue\n  }\n  return checker(value.value)\n}\n"],"mappings":"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","names":["strictEqualityComparer","a","b","simpleEqualityComparer","defaultEqualityComparer","functionEqualityComparer","Variable","value","_value","DisposableAction","LinkedChain","_LinkedChain","equalityComparer","defaultEqualityComparer","count","node","array","index","value","existing","DisposableAction","ChainNode","chainNode","tail","checkNode","valueHandler","actionTail","nextActionNode","root","next","previous","DisposableAction","CompoundVariable","Variable","initValue","equalityComparer","LinkedChain","functionEqualityComparer","defaultEqualityComparer","value","a","callback","disposable","added","disposeAll","AndVariable","CompoundVariable","variables","index","__listener","value","variable","_a","DisposableStore","CombinedVariable","CompoundVariable","vars","comparers","v","getStubArray","createArrayEqualityComparer","length","result","i","vary","value","itemEqualityComparers","a","b","stubArray","emptyDisposable","ConstantVariable","Variable","value","equalityComparer","defaultEqualityComparer","callback","emptyDisposable","_","DisposableAction","DisposableContainer","emptyDisposable","DelegateVariable","CompoundVariable","sourceOrDefaultValue","Variable","source","v","DirectVariable","Variable","initialValue","equalityComparer","LinkedChain","functionEqualityComparer","defaultEqualityComparer","value","a","callback","disposable","added","DisposableContainer","FuncVariable","CompoundVariable","activate","exactValue","disposable","self","value","DisposableAction","DisposableContainer","InvertVariable","Variable","variable","LinkedChain","functionEqualityComparer","DisposableContainer","callback","disposable","added","DisposableAction","value","v","DisposableContainer","MapVariable","CompoundVariable","variable","mapper","equalityComparer","value","DisposableStore","MaxVariable","CompoundVariable","vars","length","subscriptions","i","result","DisposableStore","MinVariable","CompoundVariable","vars","length","subscriptions","i","result","MutableVariable","Variable","value","equalityComparer","LinkedChain","functionEqualityComparer","defaultEqualityComparer","a","callback","disposable","added","disposeAll","OrVariable","CompoundVariable","variables","index","__listener","value","variable","_a","DisposableAction","DisposableContainer","emptyDisposable","SealVariable","Variable","vary","equalityComparer","LinkedChain","functionEqualityComparer","DisposableContainer","callback","emptyDisposable","disposable","added","DisposableAction","valueToSeal","currentValue","v","a","value","DisposableStore","SumVariable","CompoundVariable","vars","length","subscriptions","i","variable","result","DisposableContainer","SwitchMapVariable","CompoundVariable","vary","mapper","i","input","mappedVariable","result","DisposableContainer","noScheduledValue","ThrottledVariable","CompoundVariable","vary","onUpdate","v","value","val","DisposableAction","DisposableContainer","emptyDisposable","toDisposable","noop","DisposableAction","EventObserver","EventDispatcher","EventObserver","LinkedChain","functionEqualityComparer","action","value","a","emptyDisposable","DisposableAction","DisposableContainer","toDisposable","LazyEventDispatcher","EventObserver","activator","LinkedChain","functionEqualityComparer","DisposableContainer","callback","subscription","DisposableAction","value","a","toDisposable","DisposableStore","DisposableContainer","emptyDisposable","EventObserver","callback","subscription","DisposableContainer","value","condition","emptyDisposable","mapper","LazyEventDispatcher","dispatcher","EventDispatcher","e","createVar","activator","exactValue","FuncVariable","createConst","value","ConstantVariable","createDelegate","sourceOrDefaultValue","DelegateVariable","createDirect","initialValue","DirectVariable","or","variables","OrVariable","and","AndVariable","sum","SumVariable","min","MinVariable","max","MaxVariable","createDelayDispatcher","delay","LazyEventDispatcher","dispatcher","timeout","DisposableAction","Variable","callback","container","DisposableContainer","subscription","v","toDisposable","DisposableAction","condition","value","emptyDisposable","mapper","MapVariable","other","OrVariable","AndVariable","InvertVariable","others","CombinedVariable","SwitchMapVariable","delay","ThrottledVariable","createDelayDispatcher","receiver","noop","SumVariable","a","b","ConstantVariable","vary","SealVariable","isVariable","value","Variable","isVariableOf","typeCheckerOrExampleValue","checker","v"]}